<!DOCTYPE html>
<html>
<head>
    <title>Redirect Integration Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .pass { background-color: #d4edda; border-color: #c3e6cb; }
        .fail { background-color: #f8d7da; border-color: #f5c6cb; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
        .url-display { word-break: break-all; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Redirect URL Integration Test</h1>
    <p>This test simulates the actual redirect flow to catch any encoding issues.</p>
    
    <div id="results"></div>

    <script type="module">
        // Copy the exact functions from submit.ts
        function evaluateTemplate(template, context) {
            if (!template.includes('{{')) {
                return template;
            }
            const templateRegex = /\{\{\.([\w.]+)\}\}/g;
            return template.replace(templateRegex, (match, varName) => {
                let value = context[varName];
                if (value === undefined && varName.includes('.')) {
                    const parts = varName.split('.');
                    value = context;
                    for (const part of parts) {
                        if (value && typeof value === 'object') {
                            value = value[part];
                        } else {
                            value = undefined;
                            break;
                        }
                    }
                }
                let strValue = '';
                if (value === null || value === undefined) {
                    strValue = '';
                } else if (typeof value === 'string') {
                    strValue = value;
                } else if (typeof value === 'number') {
                    strValue = String(value);
                } else if (typeof value === 'boolean') {
                    strValue = value ? 'true' : 'false';
                } else if (Array.isArray(value)) {
                    strValue = value.map(v => String(v)).join(',');
                } else if (typeof value === 'object') {
                    if (value.e164) {
                        strValue = value.e164;
                    } else if (value.value === 'other' && value.other) {
                        strValue = value.other;
                    } else if (value.value) {
                        strValue = String(value.value);
                    } else if (typeof value.lat === 'number' && typeof value.lng === 'number') {
                        strValue = `${value.lat.toFixed(6)},${value.lng.toFixed(6)}`;
                    } else if (value.url) {
                        strValue = value.url;
                    } else {
                        strValue = JSON.stringify(value);
                    }
                } else {
                    strValue = String(value);
                }
                return strValue;
            });
        }

        function encodeTemplateInURL(url, context) {
            if (!url.includes('{{')) {
                return url;
            }

            try {
                // Try to parse as absolute URL first
                let isAbsolute = false;
                let urlObj = null;
                try {
                    urlObj = new URL(url);
                    isAbsolute = true;
                } catch {
                    // Not an absolute URL, will handle as relative
                    isAbsolute = false;
                }

                if (isAbsolute && urlObj) {
                    // Handle absolute URLs using URL object to preserve existing query params
                    const evaluatedPathname = evaluateTemplate(urlObj.pathname, context);
                    const evaluatedSearch = urlObj.search; // Keep original search string
                    
                    // Parse existing query parameters
                    const existingParams = new URLSearchParams(evaluatedSearch);
                    
                    // Evaluate templates in query parameter values
                    const newParams = new URLSearchParams();
                    existingParams.forEach((value, key) => {
                        // Evaluate template in the value
                        const evaluatedValue = value.includes('{{') 
                            ? evaluateTemplate(value, context) 
                            : value;
                        newParams.append(key, evaluatedValue);
                    });
                    
                    // Build the final URL
                    const resultUrl = new URL(evaluatedPathname, urlObj.origin);
                    newParams.forEach((value, key) => {
                        resultUrl.searchParams.append(key, value);
                    });
                    
                    return resultUrl.toString();
                } else {
                    // Handle relative URLs (starting with /) or other formats
                    // Split URL into base and query string
                    const [base, queryString] = url.split('?');
                    
                    if (!queryString) {
                        // No query string, just evaluate template in path
                        return evaluateTemplate(base, context);
                    }
                    
                    // Evaluate template in base URL
                    const evaluatedBase = evaluateTemplate(base, context);
                    
                    // Parse query string - URLSearchParams handles encoding automatically
                    const queryParams = new URLSearchParams(queryString);
                    const newParams = new URLSearchParams();
                    
                    // Process all existing query parameters
                    queryParams.forEach((value, key) => {
                        // Evaluate template in the value if it contains placeholders
                        const evaluatedValue = value.includes('{{') 
                            ? evaluateTemplate(value, context) 
                            : value;
                        // URLSearchParams will handle proper encoding automatically
                        newParams.append(key, evaluatedValue);
                    });
                    
                    // Build query string - URLSearchParams.toString() properly formats it
                    const queryStr = newParams.toString();
                    return queryStr ? `${evaluatedBase}?${queryStr}` : evaluatedBase;
                }
            } catch (e) {
                console.error('[Redirect Template] Error encoding URL:', e);
                // Fallback: just evaluate template without special encoding
                return evaluateTemplate(url, context);
            }
        }

        // Simulate redirectAction function
        function simulateRedirect(urlTemplate, context) {
            let finalUrl = urlTemplate;
            
            if (urlTemplate.includes('{{')) {
                finalUrl = encodeTemplateInURL(urlTemplate, context);
                
                // Validate URL
                try {
                    new URL(finalUrl);
                } catch (e) {
                    // If relative URL, try to validate by checking if it starts with / or http
                    if (!finalUrl.startsWith('/') && !finalUrl.startsWith('http://') && !finalUrl.startsWith('https://')) {
                        throw new Error('Invalid redirect URL');
                    }
                }
            }
            
            return finalUrl;
        }

        // Test cases based on the actual issue
        const context = {
            formId: 'test-form',
            submissionId: 29,
            formSubmissionId: 29
        };

        const testCases = [
            {
                name: 'Exact issue from team',
                input: 'http://localhost:3000/ar/listing/booking?categoryId=1100&formSubmissionId={{.formSubmissionId}}',
                expected: 'http://localhost:3000/ar/listing/booking?categoryId=1100&formSubmissionId=29',
                description: 'The exact URL format the team reported'
            },
            {
                name: 'With encoded existing param',
                input: 'http://localhost:3000/page?categoryId=1100%20test&formSubmissionId={{.formSubmissionId}}',
                expected: 'http://localhost:3000/page?categoryId=1100%20test&formSubmissionId=29',
                description: 'Existing param already has encoded value'
            },
            {
                name: 'Multiple existing params',
                input: 'http://localhost:3000/page?a=1&b=2&c=3&formId={{.formId}}',
                expected: 'http://localhost:3000/page?a=1&b=2&c=3&formId=test-form',
                description: 'Multiple existing params before template'
            },
            {
                name: 'Template param in middle',
                input: 'http://localhost:3000/page?a=1&formId={{.formId}}&b=2',
                expected: 'http://localhost:3000/page?a=1&formId=test-form&b=2',
                description: 'Template param between existing params'
            },
            {
                name: 'Relative URL',
                input: '/ar/listing/booking?categoryId=1100&formSubmissionId={{.formSubmissionId}}',
                expected: '/ar/listing/booking?categoryId=1100&formSubmissionId=29',
                description: 'Relative path URL'
            },
            {
                name: 'Special characters in existing param',
                input: 'http://localhost:3000/page?search=hello%20world&id={{.submissionId}}',
                expected: 'http://localhost:3000/page?search=hello%20world&id=29',
                description: 'Existing param with encoded spaces'
            }
        ];

        const results = [];
        testCases.forEach(test => {
            const actual = simulateRedirect(test.input, context);
            const passed = actual === test.expected;
            
            // Also check if URL can be parsed correctly
            let parseTest = { passed: true, error: null };
            try {
                const url = new URL(actual);
                const params = Object.fromEntries(url.searchParams);
                parseTest.params = params;
            } catch (e) {
                if (actual.startsWith('/')) {
                    // Relative URL, check query string manually
                    const [path, query] = actual.split('?');
                    if (query) {
                        const params = new URLSearchParams(query);
                        parseTest.params = Object.fromEntries(params);
                    }
                } else {
                    parseTest.passed = false;
                    parseTest.error = e.message;
                }
            }
            
            results.push({
                ...test,
                actual,
                passed,
                parseTest
            });
        });

        // Display results
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = results.map((r, i) => {
            const statusClass = r.passed ? 'pass' : 'fail';
            const statusIcon = r.passed ? '✅' : '❌';
            
            return `
                <div class="test-case ${statusClass}">
                    <h3>${statusIcon} Test ${i + 1}: ${r.name}</h3>
                    <p><strong>Description:</strong> ${r.description}</p>
                    <div class="url-display">
                        <strong>Input:</strong><br>
                        <code>${r.input}</code>
                    </div>
                    <div class="url-display">
                        <strong>Expected:</strong><br>
                        <code>${r.expected}</code>
                    </div>
                    <div class="url-display">
                        <strong>Actual:</strong><br>
                        <code>${r.actual}</code>
                    </div>
                    ${!r.passed ? `
                        <div style="color: red; margin-top: 10px;">
                            <strong>Mismatch detected!</strong><br>
                            Expected: <code>${r.expected}</code><br>
                            Actual: <code>${r.actual}</code>
                        </div>
                    ` : ''}
                    ${r.parseTest.params ? `
                        <div style="margin-top: 10px;">
                            <strong>Parsed Parameters:</strong><br>
                            <pre>${JSON.stringify(r.parseTest.params, null, 2)}</pre>
                        </div>
                    ` : ''}
                </div>
            `;
        }).join('');

        // Summary
        const allPassed = results.every(r => r.passed);
        const summary = document.createElement('div');
        summary.className = `test-case ${allPassed ? 'pass' : 'fail'}`;
        summary.style.marginTop = '30px';
        summary.innerHTML = `
            <h2>${allPassed ? '✅ All Tests Passed!' : '❌ Some Tests Failed'}</h2>
            <p>Passed: ${results.filter(r => r.passed).length} / ${results.length}</p>
        `;
        resultsDiv.appendChild(summary);

        // Log to console for debugging
        console.log('Test Results:', results);
        results.forEach((r, i) => {
            if (!r.passed) {
                console.error(`Test ${i + 1} FAILED:`, {
                    input: r.input,
                    expected: r.expected,
                    actual: r.actual
                });
            }
        });
    </script>
</body>
</html>





